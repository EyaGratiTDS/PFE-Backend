const { generateVCardFull, generateUniqueUrl } = require("../services/iaService");
const { uploadToCloudinary, deleteFromCloudinary } = require("../services/cloudinary");
const Project = require("../models/Project");
const VCard = require("../models/Vcard");
const Block = require("../models/Block");
const User = require("../models/User");
const axios = require('axios');

async function generateProjectLogo(projectName, job) {
  try {
    console.log(`üñºÔ∏è Generating logo for: ${projectName}`);
    
    const logoUrl = `https://img.logo.dev/${encodeURIComponent(projectName.toLowerCase())}.png?token=pk_X8bKfaWxSTSDEy_z6s5Cg&size=200`;
    
    // Check if image is accessible
    const response = await axios.head(logoUrl, { timeout: 5000 });
    
    if (response.status === 200) {
      console.log(`‚úÖ Logo generated successfully: ${logoUrl}`);
      return logoUrl;
    } else {
      throw new Error(`HTTP Status ${response.status}`);
    }
    
  } catch (error) {
    console.warn(`‚ö†Ô∏è Error generating logo: ${error.message}`);
    
    // Fallback: Generate logo with initials
    const initials = projectName
      .split(' ')
      .map(word => word.charAt(0).toUpperCase())
      .join('')
      .substring(0, 2);
      
    const fallbackUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(initials)}&background=4F46E5&color=fff&size=200&bold=true&format=png`;
    
    console.log(`üîÑ Fallback logo generated: ${fallbackUrl}`);
    return fallbackUrl;
  }
}

/**
 * üéØ Endpoint 1: Generation with logo (no save)
 * Route: POST /api/ia/generate-vcard
 */
async function generateVCard(req, res) {
  try {
    const { job, skills, userId } = req.body;
    
    console.log("üì• VCard Generation - Data received:", { 
      job, 
      skills, 
      userId,
      timestamp: new Date().toISOString()
    });
    
    // ‚úÖ Enhanced validation of required parameters
    if (!job || typeof job !== 'string' || job.trim().length === 0) {
      return res.status(400).json({ 
        success: false,
        error: "The 'job' parameter is required and must be a non-empty string"
      });
    }

    if (!userId) {
      return res.status(400).json({ 
        success: false,
        error: "The 'userId' parameter is required" 
      });
    }

    // ‚úÖ Conversion and validation of userId
    const validUserId = parseInt(userId, 10);
    if (isNaN(validUserId) || validUserId <= 0) {
      return res.status(400).json({ 
        success: false,
        error: "The 'userId' parameter must be a valid positive integer" 
      });
    }

    console.log("üîç UserId validated:", validUserId, "(type:", typeof validUserId, ")");

    // üìã Retrieve complete user data from database
    let user = null;
    try {
      user = await User.findByPk(validUserId);
      
      if (!user) {
        return res.status(404).json({ 
          success: false,
          error: "User not found with the provided ID" 
        });
      }
      
      console.log("üë§ User found:", {
        id: user.id,
        name: user.name,
        email: user.email,
        hasPhone: !!user.phone
      });
      
    } catch (dbError) {
      console.error("‚ùå Error retrieving user:", dbError.message);
      return res.status(500).json({ 
        success: false,
        error: "Error retrieving user data" 
      });
    }

    // üé® Prepare user data for AI generation
    const userData = {
      name: user.name,
      email: user.email,
      phone: user.phone,
      // Add other fields if available
      instagram: user.instagram,
      linkedin: user.linkedin,
      github: user.github,
      twitter: user.twitter,
      facebook: user.facebook,
      website: user.website
    };

    // üõ†Ô∏è Normalize skills (string or array)
    let normalizedSkills;
    if (Array.isArray(skills)) {
      normalizedSkills = skills;
    } else if (typeof skills === 'string') {
      normalizedSkills = skills.split(',').map(skill => skill.trim()).filter(skill => skill.length > 0);
    } else {
      normalizedSkills = [];
    }

    console.log("ü§ñ Calling AI service to generate VCard...");
    const { project, vcard, blocks } = await generateVCardFull(job, normalizedSkills, userData);
    
    console.log("‚úÖ Data generated by AI:", {
      projectName: project.name,
      vcardName: vcard.name,
      blocksCount: blocks.length,
      hasLogo: !!project.logo,
      hasFavicon: !!vcard.favicon,
      backgroundType: vcard.background_type
    });

    // üñºÔ∏è Generate project logo
    console.log("üñºÔ∏è Generating project logo...");
    let projectLogo = null;
    try {
      projectLogo = await generateProjectLogo(project.name, job);
      console.log("‚úÖ Project logo generated:", projectLogo);
    } catch (logoError) {
      console.warn("‚ö†Ô∏è Unable to generate logo:", logoError.message);
      // Continue without logo
    }

    // üîó Generate unique URL for VCard (not saved yet)
    const vcardUrl = generateUniqueUrl(vcard.name || userData.name || job);
    console.log("üîó Unique URL generated:", vcardUrl);

    // üì¶ Prepare data for frontend (with URL, userId and logo)
    const vcardData = {
      ...vcard,
      url: vcardUrl,
      userId: validUserId,
      is_active: true,
      is_share: true,
      is_downloaded: false,
      status: 0,  // ‚úÖ Status = 0 (false)
      search_engine_visibility: true,
      remove_branding: false
    };

    const projectData = {
      ...project,
      logo: projectLogo || project.logo, // ‚úÖ Use generated logo or AI logo
      userId: validUserId,
      status: 'active'
    };

    // üéâ Final response - VCard generated with logo but NOT saved
    console.log("üéâ Generation completed - Data ready for frontend");
    
    return res.status(200).json({
      success: true,
      message: "VCard generated successfully (not saved yet)",
      data: {
        project: projectData,
        vcard: vcardData, 
        blocks: blocks
      },
      savedToDB: false, // üö´ Indicator that VCard is NOT saved
      logoGenerated: !!projectLogo, // ‚úÖ Indicator if logo was generated
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error("‚ùå Error during VCard generation:", error);
    
    // Fine-grained error handling
    let statusCode = 500;
    let errorMessage = "Error during VCard generation";
    let errorDetails = error.message;

    if (error.message?.includes("parameter")) {
      statusCode = 400;
      errorMessage = error.message;
    } else if (error.message?.includes("not found")) {
      statusCode = 404;
      errorMessage = error.message;
    } else if (error.name === "SequelizeDatabaseError") {
      statusCode = 503;
      errorMessage = "Temporary database error";
    } else if (error.name === "SequelizeConnectionError") {
      statusCode = 503;
      errorMessage = "Database connection problem";
    }

    return res.status(statusCode).json({ 
      success: false,
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? errorDetails : undefined,
      timestamp: new Date().toISOString()
    });
  }
}

/**
 * üéØ Endpoint 2: User action management (accept/regenerate)
 * Route: POST /api/ia/vcard-action
 */
async function notifyVCardAction(req, res) {
  try {
    const { action, vcardData, projectData, blocksData, vcardId, userId } = req.body;
    
    console.log("üé¨ User action received:", { 
      action,
      vcardId: vcardId,
      hasVcardData: !!vcardData,
      hasProjectData: !!projectData,
      blocksCount: blocksData?.length || 0,
      hasProjectLogo: !!projectData?.logo,
      timestamp: new Date().toISOString()
    });
    
    // ‚úÖ Parameter validation
    if (!action) {
      return res.status(400).json({ 
        success: false,
        error: "The 'action' parameter is required"
      });
    }

    if (!['accept', 'regenerate'].includes(action)) {
      return res.status(400).json({ 
        success: false,
        error: "Action must be 'accept' or 'regenerate'"
      });
    }

    // üé≠ Processing according to action
    if (action === 'accept') {
      // ‚úÖ ACCEPTANCE - Save data received from frontend
      console.log("‚úÖ ACCEPT action - Saving data to DB");
      
      // Validation of required data for saving
      if (!vcardData || !projectData || !blocksData) {
        return res.status(400).json({ 
          success: false,
          error: "For 'accept' action, vcardData, projectData and blocksData are required"
        });
      }

      if (!userId) {
        return res.status(400).json({ 
          success: false,
          error: "userId missing in data. UserId is required for saving."
        });
      }

      console.log("üîç UserId validation:", userId);

      // üñºÔ∏è Project logo management (upload to Cloudinary if needed)
      let finalProjectLogo = projectData.logo;
      let logoPublicId = null;

      if (projectData.logo && projectData.logo.startsWith('http')) {
        try {
          console.log("üì§ Uploading logo to Cloudinary...");
          const cloudinaryResult = await uploadToCloudinary(projectData.logo, 'project_logos');
          finalProjectLogo = cloudinaryResult.secure_url;
          logoPublicId = cloudinaryResult.public_id;
          console.log("‚úÖ Logo uploaded to Cloudinary:", finalProjectLogo);
        } catch (uploadError) {
          console.warn("‚ö†Ô∏è Logo upload error:", uploadError.message);
          // Continue with original URL
        }
      }

      // 1Ô∏è‚É£ Save project with logo
      console.log("üíæ Saving project...");
      const newProject = await Project.create({ 
        name: projectData.name,
        description: projectData.description,
        logo: finalProjectLogo,
        logoPublicId: logoPublicId,
        color: projectData.color,
        userId: userId,
        status: projectData.status || 'active'
      });
      
      console.log("‚úÖ Project created with ID:", newProject.id);

      // 2Ô∏è‚É£ Save VCard
      console.log("üíæ Saving VCard...");
      const newVCard = await VCard.create({ 
        name: vcardData.name,
        description: vcardData.description,
        font_family: vcardData.font_family,
        font_size: vcardData.font_size,
        logo: vcardData.logo,
        favicon: vcardData.favicon,
        background_type: vcardData.background_type,
        background_value: vcardData.background_value,
        url: vcardData.url,
        userId: userId,
        projectId: newProject.id,
        is_active: vcardData.is_active !== undefined ? vcardData.is_active : true,
        is_share: vcardData.is_share !== undefined ? vcardData.is_share : true,
        is_downloaded: vcardData.is_downloaded || false,
        status: vcardData.status !== undefined ? vcardData.status : 0,  // ‚úÖ Fallback to 0 (false)
        search_engine_visibility: vcardData.search_engine_visibility !== undefined ? vcardData.search_engine_visibility : true,
        remove_branding: vcardData.remove_branding || false
      });
      
      console.log("‚úÖ VCard created with ID:", newVCard.id);

      // 3Ô∏è‚É£ Save all Blocks
      console.log("üíæ Saving blocks...");
      const createdBlocks = [];
      
      for (let i = 0; i < blocksData.length; i++) {
        const block = blocksData[i];
        
        try {
          const newBlock = await Block.create({
            name: block.name,
            type_block: block.type_block,
            description: block.description,
            status: block.status !== undefined ? block.status : true,
            vcardId: newVCard.id
          });
          
          createdBlocks.push(newBlock);
          console.log(`‚úÖ Block ${i + 1}/${blocksData.length} created: ${block.name} (${block.type_block})`);
          
        } catch (blockError) {
          console.error(`‚ùå Error creating block ${i + 1}:`, blockError.message);
          // Continue creating other blocks even if one fails
        }
      }

      console.log(`‚úÖ ${createdBlocks.length}/${blocksData.length} blocks created successfully`);
      
      console.log(`‚úÖ VCard accepted and saved successfully`);
      
      return res.status(201).json({
        success: true,
        message: "VCard accepted and saved successfully",
        action: 'accept',
        data: {
          project: newProject,
          vcard: newVCard,
          blocks: createdBlocks,
          status: 'accepted_and_saved'
        },
        savedToDB: true,
        logoUploaded: !!logoPublicId,
        timestamp: new Date().toISOString()
      });

    } else if (action === 'regenerate') {
      // üóëÔ∏è REGENERATION - Delete existing VCard if provided
      console.log("üóëÔ∏è REGENERATE action - Preparing for new generation");
      
      if (vcardId) {
        // If vcardId is provided, delete existing VCard
        const vcard = await VCard.findByPk(vcardId);
        
        if (vcard) {
          // Delete associated blocks first
          const blocksCount = await Block.count({ where: { vcardId: vcardId } });
          await Block.destroy({ where: { vcardId: vcardId } });
          console.log(`üóëÔ∏è ${blocksCount} blocks deleted`);
          
          // Get project ID before deletion
          const projectId = vcard.projectId;
          
          // Delete VCard
          await vcard.destroy();
          console.log(`üóëÔ∏è VCard ${vcardId} deleted`);
          
          // Delete associated project if no more VCards
          if (projectId) {
            const remainingVCards = await VCard.count({ where: { projectId: projectId } });
            if (remainingVCards === 0) {
              // Get project info to delete logo from Cloudinary
              const project = await Project.findByPk(projectId);
              if (project && project.logoPublicId) {
                try {
                  await deleteFromCloudinary(project.logoPublicId);
                  console.log(`üóëÔ∏è Logo deleted from Cloudinary: ${project.logoPublicId}`);
                } catch (cloudinaryError) {
                  console.warn("‚ö†Ô∏è Cloudinary logo deletion error:", cloudinaryError.message);
                }
              }
              
              await Project.destroy({ where: { id: projectId } });
              console.log(`üóëÔ∏è Project ${projectId} deleted (no more associated VCards)`);
            }
          }
          
          return res.status(200).json({
            success: true,
            message: "VCard deleted successfully for regeneration",
            action: 'regenerate',
            vcardId: vcardId,
            data: {
              status: 'deleted_for_regeneration',
              blocksDeleted: blocksCount,
              projectDeleted: projectId ? true : false
            },
            timestamp: new Date().toISOString()
          });
        }
      }
      
      // If no vcardId or VCard not found, simply confirm regeneration
      return res.status(200).json({
        success: true,
        message: "Ready for regeneration",
        action: 'regenerate',
        data: {
          status: 'ready_for_regeneration'
        },
        timestamp: new Date().toISOString()
      });
    }

  } catch (error) {
    console.error("‚ùå Error during user action processing:", error);
    
    let statusCode = 500;
    let errorMessage = "Error processing action";
    
    if (error.name === "SequelizeForeignKeyConstraintError") {
      statusCode = 409;
      errorMessage = "Cannot delete: existing linked data";
    } else if (error.name === "SequelizeValidationError") {
      statusCode = 400;
      errorMessage = "Invalid data for saving";
      console.error("Validation details:", error.errors?.map(e => e.message).join(", "));
    } else if (error.name === "SequelizeDatabaseError") {
      statusCode = 503;
      errorMessage = "Database error";
    }
    
    return res.status(statusCode).json({ 
      success: false,
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      timestamp: new Date().toISOString()
    });
  }
}

/**
 * üß™ Test function to verify VCard generation with logo
 * Route: POST /api/ia/test
 */
async function testVCardGeneration(req, res) {
  try {
    const { job = "developer", skills = "JavaScript, Node.js, React" } = req.body;
    
    console.log("üß™ VCard generation test with logo:", { job, skills });
    
    const testUserData = {
      name: "Test User",
      email: "test.user@example.com",
      phone: "+33612345678"
    };
    
    const { generateVCardFull } = require("../services/iaService");
    const result = await generateVCardFull(job, skills, testUserData);
    
    // Test logo generation
    const testLogo = await generateProjectLogo(result.project.name, job);
    
    return res.status(200).json({
      success: true,
      message: "Test successful",
      data: {
        ...result,
        project: {
          ...result.project,
          logo: testLogo
        }
      },
      testData: testUserData,
      logoGenerated: !!testLogo
    });
    
  } catch (error) {
    console.error("‚ùå Error during generation test:", error);
    
    return res.status(500).json({
      success: false,
      error: "Error during generation test",
      details: error.message
    });
  }
}

module.exports = {
  generateVCard,
  notifyVCardAction,
  testVCardGeneration
};